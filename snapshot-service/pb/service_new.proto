syntax = "proto3";

package snapshotservice.pb;

import "resource-aggregate/pb/resources.proto";
import "snapshot-service/pb/scene.proto";
import "snapshot-service/pb/rule.proto";
import "snapshot-service/pb/ruleActionLink.proto";

import "google/api/annotations.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
  info: {
    title: "PLGD Rule Engine API";
    version: "1.0";
    description: "API for configuring rule engine in PLGD";
    contact: {
      name: "plgd.dev";
      url: "https://github.com/plgd-dev/hub";
      email: "info@plgd.dev";
    };
    license: {
      name: "Apache License 2.0";
      url: "https://github.com/plgd-dev/hub/blob/v2/LICENSE";
    };
  };
  schemes: [HTTPS];
  consumes: ["application/json", "application/protojson"];
  produces: ["application/json", "application/protojson"];
};

option go_package = "github.com/plgd-dev/hub/v2/snapshot-service/pb;pb";

message Id {
  string id = 1;
  uint64 version = 2;
}

message IdFilter {
  string id = 1;
  oneof version {
    uint64 value = 2;
    bool all = 3;
    bool max = 4;
  }
}

message Condition {
  Id id = 1;
  string name = 2;
  bool enabled = 3;
  repeated string device_id_filter = 5;
  repeated string resource_type_filter = 6;
  repeated string resource_href_filter = 7;
  string yq_expression = 8;
  string configuration_id = 9;
  // Check if the configuration has been applied is checked against id without version.
  // To Force apply configuration user can call InvokeConfiguration to the devices.

  string api_access_token = 11; // token used to update resources in the configuration
                                // or do we want to use token from device to update self resources ?
}

message CreateConditionReponse { Id id = 1; }
message GetConditionsRequest { repeated IdFilter id_filter = 1; }
message DeleteConditionsRequest { repeated IdFilter id_filter = 1; }
message DeleteConditionsResponse { int64 count = 1; }

message RepeatedString { repeated string list = 1; }

message Configuration {
  message Resource {
    oneof filter {
      string href  = 1;
      RepeatedString resource_types = 2;
    }
    resourceaggregate.pb.Content content = 3;
    string resource_interface = 6; // optional update interface
    int64 time_to_live = 7; // optional update command time to live
  }
  Id id = 1;
  string name = 2;
  repeated Resource resources = 3;
}

message CreateConfigurationReponse { Id id = 1; }
message GetConfigurationsRequest { repeated IdFilter id_filter = 1; }
message DeleteConfigurationsRequest { repeated IdFilter id_filter = 1; }
message DeleteConfigurationsResponse { int64 count = 1; }

message AppliedResourceConfiguration {
  resourceaggregate.pb.ResourceId resource_id = 1; 
  Id configuration_id = 2;
  oneof executed_by {
    bool on_demaned = 3;
    Id condition_id = 4;
  }
  int64 timestamp_start = 5; // when the rule association was applied
  int64 valid_until = 6; // how long the command is valid
  resourceaggregate.pb.ResourceUpdated resource_updated = 7;

  enum Status {
    QUEUED = 1;
    INPROGRESS = 2;
    WAITING_FOR_REOURCE = 3;
    DONE = 4;
    TIMEOUT = 5;
  };
  Status status = 8;
}

message InvokeConfigurationRequest {
  string id = 1;
  repeated string device_id_filter = 2; // at least one must be set
  bool force = 3;
}

service SnapshotService {
  rpc CreateCondition(Condition) returns (CreateConditionReponse) {
    option (google.api.http) = {
      post: "/api/v1/conditions";
      body: "*";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Conditions" ];
    };
  }

  rpc GetConditions(GetConditionsRequest) returns (stream Condition) {
    option (google.api.http) = {
      get: "/api/v1/conditions";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Conditions" ];
    };
  }

  rpc DeleteConditions(DeleteConditionsRequest) returns (DeleteConditionsResponse) {
    option (google.api.http) = {
      delete: "/api/v1/conditions";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Conditions" ];
    };
  }

  rpc UpdateCondition(Condition) returns (UpdateConditionResponse) {
    option (google.api.http) = {
      put: "/api/v1/conditions/{id}";
      body: "*";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Conditions" ];
    };
  }

  rpc InvokeCondition(InvokeConditionRequest) returns (InvokeConditionResponse) {
    option (google.api.http) = {
      post: "/api/v1/conditions/{id}";
      body: "*";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Conditions" ];
    };
  }

  rpc CreateConfiguration(Configuration) returns (CreateConfigurationReponse) {
    option (google.api.http) = {
      post: "/api/v1/configurations";
      body: "*";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Configurations" ];
    };
  }

  rpc GetConfigurations(GetConfigurationsRequest) returns (stream Configuration) {
    option (google.api.http) = {
      get: "/api/v1/configurations";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Configurations" ];
    };
  }

  rpc DeleteConfigurations(DeleteConfigurationsRequest) returns (DeleteConfigurationsResponse) {
    option (google.api.http) = {
      delete: "/api/v1/configurations";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Configurations" ];
    };
  }

  rpc UpdateConfiguration(Configuration) returns (UpdateConfigurationReponse) {
    option (google.api.http) = {
      put: "/api/v1/configurations/{id}";
      body: "*";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Configurations" ];
    };
  }

  rpc InvokeConfiguration(InvokeConfigurationRequest) returns (stream AppliedConfiguration) {
    option (google.api.http) = {
      post: "/api/v1/configurations/{id}";
      body: "*";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Rules" ];
    };
  }
 

  rpc GetAppliedConfigurations(GetAppliedConfigurationsRequest) returns (AppliedConfiguration) {
    option (google.api.http) = {
      get: "/api/v1/configurations/applied";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Rules" ];
    };
  }

  rpc DeleteAppliedConfigurations(DeleteAppliedRuleActionLinkRequest) returns (DeleteAppliedRuleActionLinkResponse) {
    option (google.api.http) = {
      delete: "/api/v1/configurations/applied";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Rules" ];
    };
  }
}


// Trigger resource changed event fron NATs
//  1. condition satisfied
//  2. invoke configuration with ID
//  3. filter out resources where configuration has been applied by existing records in DB (resourceId, configurationId)
//  4. create applied configuration for each resource with resourceId, configurationId, queued, valid until to teoritcal maximu timeout
//  5. iterate over resources and
//  6.   set start time, validuntil, status INPROGRESS
//  6.   register nats for resource changed event
//  7.   get resource contest -> if not exist wait set status to WAITING RESOURCE and wait resource changed until timeout
//  9.   if timeout set status to TIMEOUT
//  10.  else update resource with new content and set status to DONE
