// TODO overit ze pending command sa nezmaze na neexistujucom resource ak sa device pripoji a nepublishne hned resource
// Overit correlation id - ak sa pouziva rovnake napriec viacerymi resourcami

// scenare
// - Uzivatel vie vytvorit config, automaticka (backend) inkrementacia verzie
// - Uzivatel updatne config, verzia sa inkrementuje, Modal -> chces aplikovat na vsetky uz provisionnute devici? Informovat uzivatela, ze niektore devici mozu byt offline a command moze vyexpirovat.
// - Uzivatel updatne config, verzia sa inkrementuje, informujeme uzivatela ze vsetky pending commandy z predoslej verzie budu cancelnute ako aj dalsie sekvencne updaty resourcov pre predoslu verziu

syntax = "proto3";

package snapshotservice.pb;

import "resource-aggregate/pb/resources.proto";
import "resource-aggregate/pb/events.proto";

import "google/api/annotations.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
  info: {
    title: "PLGD Rule Engine API";
    version: "1.0";
    description: "API for configuring rule engine in PLGD";
    contact: {
      name: "plgd.dev";
      url: "https://github.com/plgd-dev/hub";
      email: "info@plgd.dev";
    };
    license: {
      name: "Apache License 2.0";
      url: "https://github.com/plgd-dev/hub/blob/v2/LICENSE";
    };
  };
  schemes: [HTTPS];
  consumes: ["application/json", "application/protojson"];
  produces: ["application/json", "application/protojson"];
};

option go_package = "github.com/plgd-dev/hub/v2/snapshot-service/pb;pb";

// /configuration/123?version=latest :) Jozko spravi :)
message IDFilter {
  string id = 1; 
  oneof version {
    uint64 value = 2;
    bool all = 3;
    bool latest = 4;
  }
}

message Condition { // driven by resource change event
  string id = 1;
  uint64 version = 2;
  string name = 3;
  bool enabled = 4;
  string configuration_id = 5;
  repeated string device_id_filter = 6;
  repeated string resource_type_filter = 7;
  repeated string resource_href_filter = 8;
  string yq_expression = 9;
  string api_access_token = 10; // token used to update resources in the configuration
}

message GetConditionsRequest { repeated IdFilter id_filter = 1; }
message DeleteConditionsRequest { repeated IdFilter id_filter = 1; }
message DeleteConditionsResponse { int64 count = 1; }

message Configuration {
  message Resource {
    string href  = 1;
    resourceaggregate.pb.Content content = 3;
    int64 time_to_live = 4; // optional update command time to live, 0 is infinite
  }
  string id = 1;
  uint64 version = 2;
  string name = 3;
  repeated Resource resources = 4;
}

message GetConfigurationsRequest { repeated IDFilter id_filter = 1; }
message DeleteConfigurationsRequest { repeated IdFilter id_filter = 1; }
message DeleteConfigurationsResponse { int64 count = 1; }

message AppliedDeviceConfiguration { //TODO naming 
  message Resource {
    resourceaggregate.pb.ResourceId resource_id = 1; // TODO Jozo href only?
    string correlation_id = 2; // Reused from invoke command or generated. Can be used to retrieve corresponding pending command.
    enum Status {
      QUEUED = 0;
      PENDING = 1;
      DONE = 2;
      TIMEOUT = 3;
    };
    Status status = 3;
    resourceaggregate.pb.ResourceUpdated resource_updated = 4;
  }
  string id = 1;
  string device_id = 2;
  message RelationTo { //TODO naming
    string id = 1;
    uint64 version = 2;
  }
  RelationTo configuration_id = 3;
  oneof executed_by {
    bool on_demaned = 4;
    RelationTo condition_id = 5; //TODO Naming
  }
  repeated Resource resources = 6; //TODO naming
}

message InvokeConfigurationRequest {
  string configuration_id = 1; // applies latest configuration
  string device_id = 2;
  bool force = 3; // force update even if the configuration has already been applied to device
  string correlation_id = 4; // propagated down to the resource update command
}

message GetAppliedDeviceConfigurationsRequest { //TODO Naming
  repeated string id_filter = 1;
  repeated IDFilter configuration_id_filter = 2;
  repeated string device_id_filter = 3;
  repeated IDFilter condition_id_filter = 4;
}

message DeleteAppliedConfigurationsRequest { repeated string id_filter = 1; }
message DeleteAppliedConfigurationsResponse { int64 count = 1; }

service SnapshotService {
  rpc CreateCondition(Condition) returns (Condition) {
    option (google.api.http) = {
      post: "/api/v1/conditions";
      body: "*";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Conditions" ];
    };
  }

  rpc GetConditions(GetConditionsRequest) returns (stream Condition) {
    option (google.api.http) = {
      get: "/api/v1/conditions";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Conditions" ];
    };
  }

  rpc DeleteConditions(DeleteConditionsRequest) returns (DeleteConditionsResponse) {
    option (google.api.http) = {
      delete: "/api/v1/conditions";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Conditions" ];
    };
  }

  rpc UpdateCondition(Condition) returns (Condition) {
    option (google.api.http) = {
      put: "/api/v1/conditions/{id}";
      body: "*";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Conditions" ];
    };
  }

  rpc CreateConfiguration(Configuration) returns (Configuration) {
    option (google.api.http) = {
      post: "/api/v1/configurations";
      body: "*";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Configurations" ];
    };
  }

  rpc GetConfigurations(GetConfigurationsRequest) returns (stream Configuration) {
    option (google.api.http) = {
      get: "/api/v1/configurations";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Configurations" ];
    };
  }

  rpc DeleteConfigurations(DeleteConfigurationsRequest) returns (DeleteConfigurationsResponse) {
    option (google.api.http) = {
      delete: "/api/v1/configurations";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Configurations" ];
    };
  }

  rpc UpdateConfiguration(Configuration) returns (Configuration) {
    option (google.api.http) = {
      put: "/api/v1/configurations/{id}";
      body: "*";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Configurations" ];
    };
  }

  // streaming process of update configuration to invoker
  rpc InvokeConfiguration(InvokeConfigurationRequest) returns (stream AppliedConfiguration) {
    option (google.api.http) = {
      post: "/api/v1/configurations/{id}";
      body: "*";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Configurations" ];
    };
  }
 

  rpc GetAppliedConfigurations(GetAppliedConfigurationsRequest) returns (stream AppliedConfiguration) {
    option (google.api.http) = {
      get: "/api/v1/configurations/applied";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Configurations" ];
    };
  }

  rpc DeleteAppliedConfigurations(DeleteAppliedConfigurationsRequest) returns (DeleteAppliedConfigurationsResponse) {
    option (google.api.http) = {
      delete: "/api/v1/configurations/applied";
    };
    option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
      tags: [ "Configurations" ];
    };
  }
}

// Trigger resource changed event from NATs.
// 1. Check if condition is satisfied.
// 2. Invoke configuration with ID.
// 3. If the configuration has already been applied to the device, skip applying the configuration.
// 4. Create applied configuration with ConfigurationId and for each resource with resourceId, QUEUED status, valid until the theoretical maximum timeout.
// 5. Iterate over resources and
// 6.   Set start time, valid until, and status to IN PROGRESS.
// 7.   Register NATs for resource changed event.
// 8.   If the resource has not been published yet (href, resource types not exist), set status to WAITING RESOURCE and wait for resource changed event until timeout.
// 9.   If getting resource content fails or not found, set status to WAITING RESOURCE and wait for resource changed event until timeout.
// 10.  If timeout occurs, set status to TIMEOUT.
// 11.  Otherwise, set status to IN PROGRESS and update resource with new content. If the update fails, set status to FAIL; otherwise, set status to DONE.
