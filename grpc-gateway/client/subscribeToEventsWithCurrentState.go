package client

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/plgd-dev/cloud/v2/grpc-gateway/pb"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

type GrpcGateway_SubscribeToEventsClient struct {
	subClient  pb.GrpcGateway_SubscribeToEventsClient
	grpcClient pb.GrpcGatewayClient

	deduplicateExpiration time.Duration
	events                []*pb.Event
	removeSubs            sync.Map
	newSubs               sync.Map
	subs                  sync.Map
}

// Header returns the header metadata received from the server if there
// is any. It blocks if the metadata is not ready to read.
func (c *GrpcGateway_SubscribeToEventsClient) Header() (metadata.MD, error) {
	return c.subClient.Header()
}

// Trailer returns the trailer metadata from the server, if there is any.
// It must only be called after stream.CloseAndRecv has returned, or
// stream.Recv has returned a non-nil error (including io.EOF).
func (c *GrpcGateway_SubscribeToEventsClient) Trailer() metadata.MD {
	return c.subClient.Trailer()
}

// CloseSend closes the send direction of the stream. It closes the stream
// when non-nil error is met. It is also not safe to call CloseSend
// concurrently with SendMsg.
func (c *GrpcGateway_SubscribeToEventsClient) CloseSend() error {
	return c.subClient.CloseSend()
}

// Context returns the context for this stream.
//
// It should not be called until after Header or RecvMsg has returned. Once
// called, subsequent client-side retries are disabled.
func (c *GrpcGateway_SubscribeToEventsClient) Context() context.Context {
	return c.subClient.Context()
}

// SendMsg is generally called by generated code. On error, SendMsg aborts
// the stream. If the error was generated by the client, the status is
// returned directly; otherwise, io.EOF is returned and the status of
// the stream may be discovered using RecvMsg.
//
// SendMsg blocks until:
//   - There is sufficient flow control to schedule m with the transport, or
//   - The stream is done, or
//   - The stream breaks.
//
// SendMsg does not wait until the message is received by the server. An
// untimely stream closure may result in lost messages. To ensure delivery,
// users should ensure the RPC completed successfully using RecvMsg.
//
// It is safe to have a goroutine calling SendMsg and another goroutine
// calling RecvMsg on the same stream at the same time, but it is not safe
// to call SendMsg on the same stream in different goroutines. It is also
// not safe to call CloseSend concurrently with SendMsg.
func (c *GrpcGateway_SubscribeToEventsClient) SendMsg(m interface{}) error {
	req, ok := m.(*pb.SubscribeToEvents)
	if !ok {
		return fmt.Errorf("invalid type('%T')", m)
	}
	if req.GetCreateSubscription() != nil {
		_, ok := c.subs.Load(req.GetCorrelationId())
		if ok {
			return fmt.Errorf("duplicit correlationID(%v)", req.GetCorrelationId())
		}
		_, ok = c.newSubs.Load(req.GetCorrelationId())
		if ok {
			return fmt.Errorf("duplicit correlationID(%v)", req.GetCorrelationId())
		}
		sub := NewSub(c.subClient.Context(), c.grpcClient, c.send, req.GetCorrelationId(), c.deduplicateExpiration, req.GetCreateSubscription())
		c.newSubs.Store(req.GetCorrelationId(), sub)
	}
	if req.GetCancelSubscription() != nil {
		c.removeSubs.Store(req.GetCancelSubscription().GetSubscriptionId(), true)
	}
	return c.subClient.SendMsg(m)
}

func copyEvent(dst, src *pb.Event) {
	dst.CorrelationId = src.GetCorrelationId()
	dst.SubscriptionId = src.GetSubscriptionId()
	dst.Type = src.GetType()
}

// RecvMsg blocks until it receives a message into m or the stream is
// done. It returns io.EOF when the stream completes successfully. On
// any other error, the stream is aborted and the error contains the RPC
// status.
//
// It is safe to have a goroutine calling SendMsg and another goroutine
// calling RecvMsg on the same stream at the same time, but it is not
// safe to call RecvMsg on the same stream in different goroutines.
//
// When new devices appear, it retrieves all current state of filtered events.
// And for that, duplication of an event can occur.
func (c *GrpcGateway_SubscribeToEventsClient) RecvMsg(m interface{}) error {
	for {
		if len(c.events) > 0 {
			ev := c.events[0]
			c.events = c.events[1:]
			event := m.(*pb.Event)
			copyEvent(event, ev)
			return nil
		}
		start := time.Now()
		event := new(pb.Event)
		err := c.subClient.RecvMsg(event)
		if err != nil {
			return err
		}
		timeDiff := time.Since(start)
		eventOrig := m.(*pb.Event)
		copyEvent(eventOrig, event)
		switch ev := event.GetType().(type) {
		case *pb.Event_OperationProcessed_:
			s, ok := c.newSubs.LoadAndDelete(event.GetCorrelationId())
			if ok {
				if ev.OperationProcessed.GetErrorStatus().GetCode() != pb.Event_OperationProcessed_ErrorStatus_OK {
					return nil
				}
				sub := s.(*Sub)
				err := sub.Init(event.GetSubscriptionId())
				if err != nil {
					ev.OperationProcessed.ErrorStatus = &pb.Event_OperationProcessed_ErrorStatus{
						Code:    pb.Event_OperationProcessed_ErrorStatus_ERROR,
						Message: err.Error(),
					}
					return nil
				}
				c.subs.Store(event.GetSubscriptionId(), sub)
				return nil
			} else {
				if _, ok := c.removeSubs.LoadAndDelete(event.GetSubscriptionId()); ok {
					c.subs.Delete(event.GetSubscriptionId())
				}
				return nil
			}
		case *pb.Event_SubscriptionCanceled_:
			c.subs.Delete(event.GetSubscriptionId())
			return nil
		default:
			s, ok := c.subs.Load(event.GetSubscriptionId())
			if ok {
				sub := s.(*Sub)
				if timeDiff > time.Second {
					sub.DropDeduplicateEvents()
				}
				err := sub.ProcessEvent(event)
				if err != nil {
					return err
				}
				continue
			}
			return nil
		}
	}
}

func (c *GrpcGateway_SubscribeToEventsClient) Send(m *pb.SubscribeToEvents) error {
	return c.SendMsg(m)
}

func (c *GrpcGateway_SubscribeToEventsClient) Recv() (*pb.Event, error) {
	m := new(pb.Event)
	if err := c.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *GrpcGateway_SubscribeToEventsClient) send(event *pb.Event) error {
	c.events = append(c.events, event)
	return nil
}

// SubscribeToEventsWithCurrentState creates subscribe to events with included the current state.
// It can provide duplicity events when lots of events are in the batch. The deduplicate is driven by deduplicateExpiration argument.
// Subscription doesn't guarantee that all events will be sent to the client. The client is responsible for synchronizing events.
func (c *Client) SubscribeToEventsWithCurrentState(ctx context.Context, deduplicateExpiration time.Duration, opts ...grpc.CallOption) (pb.GrpcGateway_SubscribeToEventsClient, error) {
	subClient, err := c.gateway.SubscribeToEvents(ctx, opts...)
	if err != nil {
		return subClient, err
	}
	return &GrpcGateway_SubscribeToEventsClient{
		subClient:             subClient,
		grpcClient:            c.gateway,
		deduplicateExpiration: deduplicateExpiration,
		events:                make([]*pb.Event, 0, 1024),
	}, nil
}
